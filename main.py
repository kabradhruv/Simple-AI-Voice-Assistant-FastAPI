# main.py
"""
A simple AI Voice Assistant backend using FastAPI.
This application accepts text input (simulating voice commands),
performs basic NLP processing (via keyword matching or using the Google Gemini API),
returns a response, logs interactions, and serves a simple UI.
"""

import os
import logging
from fastapi import FastAPI
from fastapi.responses import HTMLResponse
from pydantic import BaseModel
import uvicorn
from google import genai

gemini_api_key = "AIzaSyCTLQxiUv8NMutxqRPyyficErChph8G5nc"
# MONGODB_URI="mongodb+srv://kanaxiy616:tvrOfVa5Alb7Sz5i@cluster0.wm7qp.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0"

# ------------------------------
# Gemini API Function
# ------------------------------
def get_gemini_response(input_text: str) -> str:
    """
    Generate a response using the Google Gemini API.
    
    This function requires that the environment variable GEMINI_API_KEY is set.
    It uses the client's generative text interface with a Gemini model.
    
    Args:
        input_text (str): The prompt or question for Google Gemini.
        
    Returns:
        str: The response generated by Google Gemini or an error message.
    """
    # # Retrieve the Gemini API key from the environment variables.
    # gemini_api_key = os.environ.get("GEMINI_API_KEY")
    # if not gemini_api_key:
    #     logging.error("Gemini API key not configured. Please set the GEMINI_API_KEY environment variable.")
    #     return "Gemini API key not configured."
    
    try:
        # Configure the Gemini client using the provided API key.
        client = genai.Client(api_key=gemini_api_key)
        
        # Create a text generation request.
        response = client.models.generate_content(
            model="gemini-2.0-flash", contents=input_text
        )
        
        # Extract and return the generated text.
        # The response format is assumed to include a 'result' attribute.
        if response :
            response_text = response.text
            return response_text
        else:
            logging.error("Gemini API returned an unexpected response format.")
            return "Error"
        
    except Exception as e:
        logging.error(f"Gemini API error: {e}")
        return "Error"

# ------------------------------
# MongoDB Integration
# ------------------------------
try:
    from motor.motor_asyncio import AsyncIOMotorClient
    mongodb_available = True
except ImportError:
    mongodb_available = False

# ------------------------------
# Logging Configuration
# ------------------------------
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("ai_voice_assistant")

# ------------------------------
# FastAPI Application Setup
# ------------------------------
app = FastAPI()

# ------------------------------
# Pydantic Model for Input Data
# ------------------------------
class UserInput(BaseModel):
    text: str  # User's command text

# ------------------------------
# MongoDB Integration
# ------------------------------
db_client = None
db = None

if mongodb_available and os.environ.get("MONGODB_URI"):

    mongodb_uri = os.environ.get("MONGODB_URI")
    
    # Append tlsInsecure parameter appropriately if needed:
    # if "?" in mongodb_uri:
    #     mongodb_uri += "&tlsAllowInvalidCertificates=true"
    # else:
    #     mongodb_uri += "?tlsAllowInvalidCertificates=true"

    db_client = AsyncIOMotorClient(mongodb_uri)
    db = db_client["ai_voice_assistant"]
    logger.info("MongoDB connection established.")
else:
    logger.info("MongoDB not configured. Skipping database integration.")

logger.info("MONGODB_URI: " + str(os.environ.get("MONGODB_URI")))

# ------------------------------
# Helper Function: Save Interaction
# ------------------------------
async def save_interaction(input_text: str, response_text: str):
    """
    Save the interaction (user input and response) to MongoDB if configured.
    """
    if db is not None:
        try:
            interaction = {"input": input_text, "response": response_text}
            await db.interactions.insert_one(interaction)
            logger.info("Interaction saved to the database.")
        except Exception as e:
            logger.error(f"Failed to save interaction: {e}")
    else:
        logger.info("Database not configured. Interaction not saved.")


# ------------------------------
# API Endpoint: Process User Input
# ------------------------------
@app.post("/process")
async def process_text(user_input: UserInput):
    """
    Process the user's text input and return a response.
    If a Gemini API key is available, use the Gemini API to generate the response.
    Otherwise, use basic keyword matching.
    """
    # Check if GEMINI_API_KEY is set in the environment.
    
    if gemini_api_key:
        # Use the Gemini API to get a response.
        response = get_gemini_response(user_input.text)
    else:
        # Fallback to basic keyword matching for intent recognition.
        text = user_input.text.lower()
        if "weather" in text:
            response = "Fetching weather information..."
        elif "news" in text:
            response = "Getting the latest news..."
        else:
            response = "Sorry, I didn't understand that."

    # Log the interaction and save it to the database if configured.
    logger.info(f"Received input: '{user_input.text}' | Responding with: '{response}'")
    await save_interaction(user_input.text, response)
    return {"response": response}

# ------------------------------
# UI Endpoint: Serve the HTML Page
# ------------------------------
@app.get("/", response_class=HTMLResponse)
async def get_index():
    """
    Serve the index.html file as the homepage.
    """
    try:
        with open("index.html", "r", encoding="utf-8") as file:
            html_content = file.read()
        return HTMLResponse(content=html_content, status_code=200)
    except Exception as e:
        logger.error(f"Error reading index.html: {e}")
        return HTMLResponse(content="<h1>Internal Server Error</h1>", status_code=500)

# ------------------------------
# Main Block to Run the Application
# ------------------------------
if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
